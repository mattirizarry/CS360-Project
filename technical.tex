\documentclass[11pt]{article}
\usepackage{graphicx} % This lets you include figures
\usepackage{hyperref} % This lets you make links to web locations
\usepackage[margin=0.5in]{geometry}
\usepackage[rightcaption]{sidecap}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{imakeidx}
\usepackage{indentfirst}
\makeindex
%---------------------------Do Not Edit Anything Above This Line!!------------------------

% edit the line below, if needed, to change the directory name for your image files.
\graphicspath{ {./images/} }



\begin{document}

%---------------------------Edit Content in the Box to Create the Title Page--------------
\begin{titlepage}
   \begin{center}
       \vspace*{1cm}
	   \Huge
       \textbf{Star Wars}

       \vspace{0.5cm}
       \Large
       Sprint 1\\
       September 7th, 2023 \\
   \end{center}

       \vspace{1.5cm}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Name} & \textbf{Email Address} \\ \hline
Matthew Irizarry         & matthew.irizarry745@topper.wku.edu         \\ \hline
Zach Vance         & zachary.vance141@topper.wku.edu         \\ \hline
Keimon Bush         & keimon.bush105@topper.wku.edu        \\ \hline
Jeremiah Harris         & jeremiah.harris978@topper.wku.edu         \\ \hline
\end{tabular}
\end{table}

%Latex Table Generator    
%https://www.tablesgenerator.com/     
        
\vspace{4in}

\centering        
CS 360 \\
Fall 2023\\
Project Technical Documentation

\end{titlepage}
%---------------------------Edit Content in the Box to Create the Title Page--------------


% No text here.


%---------------------------Do Not Edit Anything In This Box!!------------------------
%Table of contents and list of figures will be autogenerated by this section.
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\clearpage
\newpage
\setcounter{page}{1}%
\cleardoublepage
\pagenumbering{gobble}
\listoffigures
\cleardoublepage
\pagenumbering{arabic}
\newpage
%---------------------------Do Not Edit Anything In This Box!!------------------------




%---------------------------Project Introduction Section------------------------------

% No text here.

\section{Introduction} %\section{} is used to create major section headers

% No text here.

%---------------------------Project Overview------------------------------------------
\subsection{Project Overview} %\subsection{} is used to create minor sections 
% 300 words
% Description of the project, what the project provides, its purpose, problems solved, and target audience.

This project will attempt to produce a recreation of the 1991 Star Wars game that was produced for the SEGA Master System. While we will not be recreating every level and aspect of the game, the aim is to create a fun, quality homage to the original. This means that at the end of delivery, the game should have minimal bugs, be performant on the targeted systems, and have gameplay that is smooth and fun. Moreover, the gameplay should be true and as close to the original as possible. The target audience is someone who already has some gaming experience, but the gameplay should be friendly and welcoming to a beginner.
 

%---------------------------End Project Overview---------------------------------------

% No text here.

%---------------------------Project Scope----------------------------------------------
\subsection{Project Scope}
% 350 words
% Description of all deliverables, benefits, outcomes, and work required (all tasks, costs, time, people, resources, dates/deadlines, and final deliverables date).

This section will discuss the scope of the project. It is important to our client that our game replicate the original SEGA Master System Star Wars game very closely. In order to accomplish this goal, we must first understand what the scope of our project is. Our client does not need every single level, but needs one level that is high in quality. This means that we will likely iterate on scope items several times before their final delivery. 

\subsubsection{Title and Splash Screen}

It is important to the client that a player of this recreation be able to recognize the branding associated with Lucasfilms and the Star Wars Franchise. This is the player’s first impression of the game, so it is important that we get this part right. Much like in the movies, this includes a sliding wall of text that introduces the player to the story.

\subsubsection{Textures and Art}

In consideration of the original game, we will use the same art style. The art style used by the original game was a result of the hardware limitations at the time, which was an 8-bit computer. Therefore, we will use an 8 bit art style. We will either download textures from open-source locations and utilize them, or we will need to create our own. In consideration of the varying amount of textures, this will take up a significant amount of time for development and proper integration.

\subsubsection{Player Input}

It is important that the player has a smooth, and responsive playing experience. In order to accomplish this, we must effectively implement player controls for the player sprite. This includes functionality such as: jumping, crouching, and moving left to right.

\subsubsection{Projectiles and Collision}

There are a few distinct weapons in the game, but lots of enemies use projectiles. For example, the Jawa enemy, and storm troopers.

\subsubsection{Enemies}

There are several enemies in the game, with a few different abilities. This should be relatively easy to implement, and we can take advantage of the C\# object oriented programming paradigm to share similar traits amongst enemies and players, such as health, XY location, and more. 

\subsubsection{Level Design}

There are many unique components of this level design. Yes, it is a basic 2D platformer style, however there are some unique components of the environment such as jump boosting. These components allow the player to have a more interactive playing experience, and elevates the environment beyond just the basic 2D movement. For example, there is a conveyor belt component that horizontally speeds the player up. Moreover, there are up and down platforms that players must jump on at the proper time in order to progress through the level. If the player gets caught beneath the platform, they should take damage. Another thing the environment offers are little health boosts that are placed throughout the map.

\subsubsection{Sounds}

The sounds in this game are synonymous with an 8 bit game, and as such we will likely be able to find the original sounds themselves to implement, or be easily able to reproduce them ourselves. This is much like the textures, and is a part of the detailing phase of this project.


%---------------------------End Project Scope---------------------------------------

% No text here.


\subsection{Technical Requirements}


%---------------------------Functional Requirements----------------------------------------------
\subsubsection{Functional Requirements} %\subsubsection{} used to create sections for parent subsections.
% Functional requirements define what a system or software must do, specifying the desired behavior or functionality.

% List as atomic bullet points that can be tested

\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Functional Requirements} \\ \hline
Character input with keyboard or mouse                               \\ \hline
Support for multiple players (account creation) \\ \hline
Login system for users and administrators \\ \hline
A save game system \\ \hline
Splash screen \\ \hline
\end{tabular}
\end{table}

% Paragraph (150 words) explaining the need and purpose for the listed Functional Requirements.

Functional requirements are an important component of proper project planning and coordination. They allow for the client and development team's expectations to meet so there are not any miscommunications regarding expectations. Proper expression of product requirements, including functional requirements allows for the development team to produce the product to the specifications of the client. The mandatory functional requirements that the client has expressed to the development team includes: controlling the main character via keyboard or gamepad, account creation for multiple players, a login system for users and administrators, a save game system, and a splash screen. 

For the scope of this project, the development team will only be implementing keyboard controls. Using the keyboard, a player will be able to jump, walk left and right, and fire projectiles at enemies. Each execution of a control will interact with the environment, play a sound clip, execute an animation, and/or move the character. The team will source as many of these assets (sounds clips, animations, sprites) online and will not be creating them in house. 

A login system has been requested to be added to the recreation of the base game, which will allow both users and admins to login. With a username and login, players and admins alike will be able to login to the system. Admins will be able to access and edit account info for players. 

In addition to the login system, the client has requested that the state of the game be saved for all players and allow players to continue once they've logged back into their accounts. The player will be able to simply pause the game and logout and the game will automatically be saved. When logging back in users will either be able to continue from their previous game or be able to start a new game. Both the login credentials and the save states of the game will be stored in a database. 

The splash screen will display an appropriately themed backdrop image when the user launches the game. The splash screen will also function as a highscore display and a login screen.


%---------------------------End Functional Requirements----------------------------------------------

% No text here.

%---------------------------Non-Functional Requirements----------------------------------------------
\subsubsection{Non-Functional Requirements}
% Non-functional requirements specify the constraints, qualities, or attributes that the system or software must possess, such as performance, security, usability, portability, fault tolerance, or reliability.

% List as atomic bullet points that can be tested
\begin{table}[h!]
\centering
\begin{tabular}{|l|}
\hline
\textbf{Mandatory Non-Functional Requirements} \\ \hline
Project reliability                               \\ \hline
Smooth and responsive player experience                        \\ \hline
Quality UI/UX, meaningful controls    \\ \hline
Accessible textures and visual aspects\\ \hline
\end{tabular}
\end{table}

% Paragraph (150 words) explaining the need and purpose for the listed Non-Functional Requirements.


%use blank lines to begin a new paragraph

This section will talk about the non-functional requirements of our project and their importance. When it comes to non-functional requirements they are not mandatory for something to operate but are still very much important, as they help the overall experience of a user. These requirements will help ensure that we make a project that can meet a user's expectations and overall improve the quality of said project.

One of the first important non-functional requirements we must think about for our project is how reliable the project is. For example if the game we create is slow or is prone to crashing this will hurt the overall project's quality. When creating our project we will need to ensure that we make the game reliable to where it is expected to be able to run with very few to no crashes. This is because a user will expect this project to be reliable in the sense that they do not have to fear or worry about crashes. If a project is seen as prone to crashing the user will be unable to trust in the project as a whole and will reject it.

As well as needing to make the game able to run at a good enough speed that the gameplay feels fluid. This means that the game will be able to take in and execute commands at high speeds. The output of the game will not seem laggy or incomprehensibly too fast for a user. All of this ensures the user is able to react and respond to actions or events that are taking place in the game. Vastly improving the quality as the user will not feel that any losses are cheap, unfair, and were out of their control.

Another non-functional requirement to be sure we implement is button layout and good feeling controls. What I mean by this is that something that is overlooked until it becomes an issue is the use of buttons and their corresponding actions. For example most games use the space bar or A for xbox, X for playstation, for the simple jump mechanic. Generally depending on the console or system of play the name of the button can change but games released for the system will stick to this button. The reason for this is because most people prefer certain buttons to perform certain actions and a jump mechanic being put as these buttons have no backlash from players. But if one were to put the jump button in an awkward position the user would not be happy. This issue can even become worse if all the buttons are placed awkwardly and in non-user friendly positions. 

The last non-functional requirement to talk about is about the presentation of the game, or in other words the visuals of said project. We need to ensure that the visuals we use are clearly visible for the player as well as not painful on the eyes. For example if everything is too cluttered or if the visuals just look poor overall the player will have a hard time enjoying the game. This can even make it difficult to play if the visuals are not properly thought out.



%---------------------------End Non-Functional Requirements---------------------------------------

% No text here.

%---------------------------Target Hardware Details----------------------------------------------
\subsection{Target Hardware Details}
% 300 words minimum
% CPU (if a specific architecture is needed), RAM (required while the product is running), Persistent Storage Space, Network connection (Wi-Fi, Ethernet), Network bandwidth (required while the product is running), Output devices (Monitor (how many? What resolution?), speakers, VR headset), Input devices (Keyboard, mouse, touchscreen, VR headset).  Create test cases for each to verify.

\subsubsection{General Requirements}

When making software it's important to understand what hardware you are targeting and how to cater your software towards the ideal client's device while maximizing hardware coverage reach other clients. This section will go over the general hardware requirements we are targeting and then will go over some specific requirements that will be covered as the game is developed.  

Unity is a universally accessible software that can target phone devices, gaming consoles, Linux, Windows, Macintosh, and other platforms as well. Consequently, that means we don’t necessarily, development-wise, have to make any significant accommodations to target most of our desired platform since clients can most likely run the game on virtually any machine. Even with that being the case, there are some preliminary requirements that some machines have to abide by in terms of what versions of said OS or devices are supported by the game.

Unity offers developers the freedom to choose what version of the Unity Engine to develop, test, and build their game with. This offers a lot of flexibility for developers to use older libraries or plug-ins that are deprecated or only support specific versions of the Engine. As a result, different versions of the Unity Engine have certain requirements for supported devices. For example, the Unity 2022 version supports Windows 7, Windows 10, and Windows 11 versions, while the Unity 2023 version supports Windows 10, and Windows 11, but does not support  Windows 7. There are other requirements such as GPU, CPU, and various miscellaneous requirements for each hardware to follow.

For this project, we are generally targeting low-end desktops and laptops that meet at least the minimum requirements for Unity. This makes sure that our client who most likely surpasses the minimum requirements can play the game as well as other potential clients as the game has as much hardware coverage as possible.

\subsubsection{Specific Requirements}

The game could potentially have many input devices but we will only focus on keyboard and mouse for this scope. The game will feature simple controls as it is a simple “run and gun” platformer that requires no complex controls or mechanical skills as the character is either jumping, going in one direction, or shooting a projectile. With that being the case, a keyboard and mouse will be necessary to navigate the menu and play the core game as we will initially make controls for the keyboard, but Unity has an input manager that can also let us make other control schemes for other input devices, but the only mandatory input requirement is the keyboard and mouse.

As output devices are concerned, there are requirements that computers will meet naturally as most devices come with a monitor, sound system/, etc., but we will restate them for clarity. A monitor is necessary for the game as it will let our users interact with the game. Additionally, we can target most monitor resolutions as Unity has options for the UI and characters can scale up or down to meet requirements for specific resolutions, but to match the original game the game it will be planned to play in full screen, making use of all of the monitor screen space. On the alternative, we will have sounds in the game, but an audio system isn't required as sounds only look to immerse the player and not necessary for core gameplay.

As far as the memory components of the hardware, they should be low end providing no strain on the user's device. Concerning the CPU(x64) and RAM(4+GBs) if the computer meets the minimum requirements for Unity we will have no issue running our game. Also, storage-wise we predict the game to be less than 1.5 gigabytes so the users will not need much space to have the game on their device.


%---------------------------End Target Hardware Details----------------------------------------------

% No text here.

%---------------------------Software Product Deveopment----------------------------------------------
\subsection{Software Product Development}
% 300 words minimum
% List the following used with their purpose for development: IDEs, IDE plugins, Software Languages, Software Frameworks, Version Control, Asset Generation Tools, and tools for colaboration (Google Drive, One Drive, GitHub, etc.).  Describle how each tool is used within your team.

\subsubsection{IDE/Programming Language}

The development team will be using C\# primarily as the core language for this project to develop the game. C\# has plenty of IDEs that support it, but we will most likely use Microsoft’s Visual Studio and/or Visual Studio code. Both IDEs work very well with C\# and have packages that will allow you to work with Unity and its various libraries. It also allows for AI auto-completion of lines of code, syntax error markup, and many other utilities that will allow for the development of the game to go as efficiently as possible.

\subsubsection{Version Control with GitHub}

GitHub is a superb tool that not only allows for version control but also collaboration with its website features. GitHub will allow us to manage our game and make sure that all devs have access to the correct version of the development space. This is significant because if there is a desync in the development space it could cause workflow problems and code conflicts that can hinder development. GitHub is also accessible in many ways as well such as through IDEs, desktop applications, terminals, and many other channels. The software also allows us to collaborate by offering features such as code reviews that will allow us to double-check new code and scripts being added, as well as a comment system so that for every pull request the developers can explain what they are editing in the project, and project branches so that the main branch of the project doesn’t get messed up with many changes at once.

\subsubsection{Software Frameworks / Asset Generation}

The Unity software has many tools that we can use within it to code certain functionality. One of those tools is the physics engine, which allows users to move the player character and other entities as well as non-player objects through game space. Additionally, it will have collision detection which is key for letting the game know when certain events need to happen, for example, when the bullet hits the player we need to let the game know at that moment to take health points from the player. There are visual functionality such as the animator, canvas system, and tilemap system that will allow the developers to create an immersive visual experience which is fully customizable by the devs. There is also the UnityEngine class that most code will be developed for even further control of characters, visual elements, physics, and various other parts of the game. Furthermore, if there are any assets or plug-ins we need Unity asset store and package manager that will allow developers to import and download any asset for the completion of the project.


%---------------------------End Software Product Deveopment-----------------------------------------

% No text here.

%---------------------------End Project Introduction Section----------------------------------------


% No text here.





%---------------------------Modeling and Design Section------------------------------
\section{Modeling and Design}
% No text here.


%---------------------------System Boundaries------------------------------
\subsection{System Boundaries}

\subsubsection{Physical}
%150 words minimum
% Describe the Physical System Boundaries.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/picture_of_Physical_boundaries.png}
%    \caption{Description of the image here.}
%    \label{phy_boundaries}
%\end{figure}






\subsubsection{Logical}
%150 words minimum
% Describe the Logical System Boundaries.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/picture_of_Logical_boundaries.png}
%    \caption{Description of the image here.}
%    \label{log_boundaries}
%\end{figure}

%---------------------------End System Boundaries------------------------------

% No text here.

%---------------------------Wireframes and Storyboard----------------------------------
\subsection{Wireframes and Storyboard}
%250 words minimum
% Use wireframes to create scenes and images of the user interface.  Connect the wireframes to show progression through the product to create a storyboard.  Describe the wireframes and storyboard.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/picture_of_storyboard.png}
%    \caption{Description of the image here.}
%    \label{storyboard}
%\end{figure}

%---------------------------End Wireframes and Storyboard----------------------------------

% No text here.

%---------------------------Unified Modeling Language----------------------------------
\subsection{UML}

\subsubsection{Class Diagrams}
%At least one for each design pattern category.   
%Each class diagram should include the following:
%	Title for each Class Diagram
%	Description of how and why each class is used
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/class_diagram.png}
%    \caption{Description of the image here.}
%    \label{class_diagram}
%\end{figure}


\subsubsection{Use Case Diagrams}
%Enough to cover all technical functional requirements.
%Each Use Case Diagram should include the following:
%	Title for each Use Case Diagram
%	A description of information given in the diagram.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/use_case_diagram.png}
%    \caption{Description of the image here.}
%    \label{use_case_diagram}
%\end{figure}


\subsubsection{Use Case Scenarios Developed from Use Case Diagrams (Primary, Secondary)}
%Should include at least one primary and zero to many secondary scenarios
%Each Use Case Scenario should include the following:
%	Title for each Use Case Scenario
%	A short description of the information given in the scenario.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/use_case_scenario.png}
%    \caption{Description of the image here.}
%    \label{use_case_scenario}
%\end{figure}


\subsubsection{Sequence Diagrams}
%Each diagram should include all actors/resources to cover one Use Case Scenario.
%	Each Sequence Diagram should include the following:
%	Title for each Sequence Diagram
%	A short description of the information given in the diagram.
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/use_case_scenario.png}
%    \caption{Description of the image here.}
%    \label{use_case_scenario}
%\end{figure}

\subsubsection{State Diagrams}
%Each diagram should identify the object/resource/asset (in the title of the diagram) and display all states and actions/events that create state changes.
%	Each State Diagram should include the following:
%	Title for each State Diagram
%	A short description of the information given in the diagram
%	Mapping to source code (in the Appendix, specific files and line numbers) of where it’s used
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/state_diagram.png}
%    \caption{Description of the image here.}
%    \label{state_diagram}
%\end{figure}

\subsubsection{Component Diagrams}
%Single diagram that defines component APIs and communication pathways for all software and dependencies used in the product.
%	The Component Diagram should include the following:
%	Title for the Component Diagram
%	A description of the information given in the diagram
%	Protocols used for each communication pathway
%	Mapping to all source code and dependency software (in the Appendix, specific files)
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/component_diagram.png}
%    \caption{Description of the image here.}
%    \label{component_diagram}
%\end{figure}

\subsubsection{Deployment Diagrams}
%Single diagram that defines the physical nodes, virtual nodes, and communication for all software related to the product.  Should be an extension of the Component Diagram.
%	The Deployment Diagram should include the following:
%	Title for the Deployment Diagram
%	A description of the information given in the diagram
%	Identify all physical and virtual nodes used for process execution
%	Identify all internal and external node communication
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/deployment_diagram.png}
%    \caption{Description of the image here.}
%    \label{deployment_diagram}
%\end{figure}


%---------------------------End Unified Modeling Language----------------------------------

% No text here.

%---------------------------Version Control------------------------------------------------
\subsection{Version Control}
%200 words minimum
%Describe your group's approach to version control.  Include details on how and when you make commits to GitHub.  Explain version naming, branching, and integration approaches.
Text goes here.


%---------------------------End Version Control------------------------------------------------

% No text here.

%---------------------------Data Dictionary------------------------------------------------
\subsection{Data Dictionary}
%200 words minimum and table
%	Create a table that displays your Data Dictionary and describe how it is being used to define data structures and other major variables/elements in the software product.
Text and table goes here.


%---------------------------End Data Dictionary------------------------------------------------


% No text here.

%---------------------------User Experience Details------------------------------------------------
\subsection{User Experience}

\subsubsection{Gameplay Diagram}
%150 words minimum
%Also called a controlled flow graph.  Insert an image of the gameplay diagram and describe the diagram in detail.
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/gameplay_diagram.png}
%    \caption{Description of the image here.}
%    \label{gameplay_diagram}
%\end{figure}

\subsubsection{Gameplay Objectives}
%150 words minimum
%Should explain why someone should play your game. Should define the goals of your game.
Text goes here.

\subsubsection{User Skillset}
%150 words minimum
%Describe the abilities a user should have in order to interact with the software: Screen tapping, Memorization, Puzzle, solving, Strategy development, Quick reflexes 
Text goes here.

\subsubsection{Gameplay mechanics}
%150 words minimum
%Thorough guide of the game rules: Turn-based, Random chances, Capturing/eliminating, Time-based, Team-based
Text goes here.

\subsubsection{Gameplay Items}
%150 words minimum
%This section of the GDD refers to smaller elements of the game, such as: Health/power-ups, Coins, Loot crates, Weapons/character upgrades, Etc. Changes gameplay elements as the player progresses through the game.
Text goes here.

\subsubsection{Gameplay Challenges}
%150 words minimum
%Description of game challenges as a player progresses. Identify how a player handles difficulties and ensures the player can obtain essential tools to continue progressing through the game.
Text goes here.

\subsubsection{Gameplay Menu Screens}
%150 words minimum and wireframes
%Game start menu screen, pause menu screen, game over screen
%Give wireframe/drawing/image for all menus in the game.
Text goes here.

\subsubsection{Gameplay Heads-Up Display}
%150 words minimum and wireframes
%Current Game information visually relayed to the player as a part of the game’s user interface.
%HUD features are generally static, on-screen so they remain visible during gameplay. Health/Lives, Time, Weapons/Ammo, Capabilities, Menus, Mini-Map, Score, etc.
Text goes here.

\subsubsection{Gameplay Art Style}
%100 words minimum
%describe the visual appearance of characters, objects, and other in-game elements. (Realistic, Cartoon, etc.)
Text goes here.


\subsubsection{Gameplay Audio}
%150 words minimum
%Description of all game audio: Character sound/voices, Ambient world sounds, Background music, etc.
Text goes here.



%---------------------------End User Experience Details------------------------------------------------

% No text here.


%---------------------------End Modeling and Design Section----------------------------------


% No text here.


%---------------------------Non-Functional Product Details Section---------------------------
\section{Non-Functional Product Details}

%---------------------------Product Security-------------------------------------------------

\subsection{Product Security}

\subsubsection{Approach to Security in all Process Steps}
%250 words minimum
%Describe how your team modified the original technical document to address security issues in the Requirements, Modeling and Design, and Implementation sections.
Text goes here.


\subsubsection{Security Threat Model}
%200 words minimum and Security Threat Model
%Create and add a Security Threat Model, related to the Deployment Diagram, that identifies trust boundaries and potential security risks
Text goes here.

\subsubsection{Security Levels}
%250 words minimum
%Describe the different security levels for general users and administrators.  Also describe the authentication/authorization techniques for users of the software product.
Text goes here

%---------------------------End Product Security-------------------------------------------------

% No text here.

%---------------------------Product Performance-------------------------------------------------

\subsection{Product Performance}


\subsubsection{Product Performance Requirements}
%200 words minimum and list of performance non-functional requirements.
%Define and justify performance requirements.  These should be added to the list of non-functional requirements.
Text goes here.

\subsubsection{Measurable Performance Objectives}
%200 minimum words and list of objectives.
%Measurable Performance Objectives should be stated in this section that relate to the performance requirements.
Text goes here.

\subsubsection{Application Workload}
%250 words minimum
%Application Workload information should be gathered and visualized in this section.  This generally requires historical data on how the software product is being used.  For example, users generally spend 10% of the time interacting with menus, 80% of the time interacting with main features, 5% of the time saving work, etc.  These workloads should not be assumptions or guesses.  Timers need to be created for all major UI features of the product to generate reliable application workload analysis.
Text goes here.

\subsubsection{Hardware and Software Bottlenecks}
%250 words minimum
%Hardware and Software Bottlenecks should be identified and discussed in this section, with test cases to justlify.
Text goes here.

\subsubsection{Synthetic Performance Benchmarks}
%250 words minimum
%Synthetic Performance Benchmark test cases should be developed and executed on target hardware.  Results should be visualized and discussed in terms of the required target hardware details. (File I/O, CPU, Database).  Sysbench
Text goes here.


\subsubsection{Performance Tests}
%250 words minimum and test case description with results
%Performance Test Cases should be given in this section.  Test Cases should be executed and results should be visualized (Images, Graphs, etc.)
%examples of performance tests include, but not limited to: Load testing (expected and peak loads, exceeding peak loads), Stress testing, throughput testing, function call timers, compatability testing, fault tolerance testing, etc.
Text goes here


%---------------------------End Product Performance-------------------------------------------------

% No text here.


%---------------------------End Non-Functional Product Details Section---------------------------



% No text here.



%---------------------------Software Product Testing Section-------------------------------------
\section{Software Testing}



%---------------------------Software Testing Plan Template-------------------------------------

\subsection{Software Testing Plan Template}
%Each of the testing levels (unit, Integration, System, Acceptance) should use the following test plan template.

\textbf{Test Plan Identifier:} %Provides a unique identifier for the test. Every test should have a unique identification number for reference.

\textbf{Introduction:} % 50 words minimum. Brief description and objective about the test type.

\textbf{Test item:} %50 words minimum. Includes detailed information about the Software Under Test (SUT).

\textbf{Features to test/not to test:} %50 words minimum. In scope features. This could be newly added or updated features. Out of scope features not tested. [Provide reasoning for exclusion, like, non-impacted, low priority, etc.]

\textbf{Approach:} %50 words minimum. Strategy to test the software. Includes types of tests and how to test. Functional, performance, security testing using combined [manual + automation], manual only, automation only approach.

\textbf{Test deliverables:} %50 words minimum. All the deliverables from the testing e.g. approaches, test cases, reports etc.

\textbf{Item pass/fail criteria:} %50 words minimum. Entry and Exit criteria for all items. 

\textbf{Environmental needs:} %50 words minimum. Infrastructure required for SUT and executing test cases.

\textbf{Responsibilities:} %50 words minimum. Roles and responsibilities for various testing / supported activities.

\textbf{Staffing and training needs:} %50 words minimum. Training needs to bridge the gap of available and expected skill.

\textbf{Schedule:} %50 words minimum.  Test schedule should also be noted in the Gantt Chart. Test estimation (Efforts) and high-level schedule. Schedule should be for key deliverables or important milestones. Ideally, all test deliverables included in the test plan should be scheduled.

\textbf{Risks and Mitigation:} %100 words minimum. Risk identification for applicable items, assumptions, and mitigation plan.

\textbf{Approvals:} %Approvals and sign of dates.

%---------------------------Software Testing Plan Template-------------------------------------


% No text here.



%---------------------------Unit Testing-------------------------------------
\subsection{Unit Testing}
%copy of the completed Unit test plan should be placed here.
Text goes here.

\subsubsection{Source Code Coverage Tests}
%150 words minimum
%Insert Flow Graph Image(s).  Define cyclomatic complexity, basis paths, and Unit Test Cases
Text goes here.

%uncomment the section below when you're ready to insert an image
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=1\textwidth]{images/flow_graph.png}
%    \caption{Description of the image here.}
%    \label{flow_graph}
%\end{figure}



\subsubsection{Unit Tests and Results}
%All unit tests results visualized (table, graph, etc.)
Text goes here.


%---------------------------End Unit Testing-------------------------------------

% No text here.

%---------------------------Integration Testing-------------------------------------
\subsection{Integration Testing}
%copy of the completed Integration test plan should be placed here.
Text goes here.

\subsubsection{Integration Tests and Results}
%All integration tests results visualized (table, graph, etc.)
Text goes here.


%---------------------------End Integration Testing-------------------------------------

% No text here.


%---------------------------System Testing-------------------------------------
\subsection{System Testing}
%copy of the completed System test plan should be placed here.
Text goes here.

\subsubsection{System Tests and Results}
%All system tests results visualized (table, graph, etc.)
Text goes here.


%---------------------------End System Testing-------------------------------------

% No text here.


%---------------------------Acceptance Testing-------------------------------------
\subsection{Acceptance Testing}
%copy of the completed Acceptance test plan should be placed here.
Text goes here.

\subsubsection{Acceptance Tests and Results}
%All Acceptance tests results visualized (table, graph, etc.)
Text goes here.


%---------------------------End System Testing-------------------------------------

% No text here.





%---------------------------End Software Product Testing Section-------------------------------------


% No text here.



%---------------------------Conclusion Section-------------------------------------
\section{Conclusion}
%300 words minimum
%Concluding remarks that summarizes the purpose and outcomes of the technical document.  Discussion of short comings and future work.
Text goes here.

%---------------------------End Conclusion Section-------------------------------------


% No text here.



%---------------------------Appendix Section-------------------------------------------
\section{Appendix}

\subsection{Software Product Build Instructions}
%Include in this section all steps for copying the current state of the product to new computers for continued development.
Text goes here.

\subsection{Software Product User Guide}
%Include in this section an overview guide on how to use your software product for a general user and an administrative user.
Text goes here.

\subsection{Source Code with Comments}
%Include in this section all final source code for the product.  Label each file with headings such as, C.1 file1.c, C.2 file2.c, C.3 file1.py, etc.  All source code should be effectively commented.
Text goes here.







%---------------------------End Appendix Section-------------------------------------------














%example image:  uncomment to show usage
%\begin{figure}[h]
%    \centering
%    \includegraphics[width=1\textwidth]{images/Add_non-music.png}
%    \caption{This is how you add non-music items.}
%    \label{fig16}
%\end{figure}


%example links:  uncomment to show usage.
%\url{https://www.youtube.com}
%\href{https://www.wku.edu/}{WKU Homepage}
%\footnote{You can put the link in a footnote like this.}

% Anything to the right of a percent sign will be ignored by LaTeX.
% You can use this to put notes to yourself.  



\end{document}
